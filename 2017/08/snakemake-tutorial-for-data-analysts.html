<!DOCTYPE html>
<html lang="en">

<head>
      <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>Analysis preservation using Snakemake</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="/" rel="canonical" />

  <!-- Feed -->

  <link href="/theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="/theme/css/code_blocks/github.css" rel="stylesheet">

    <!-- CSS specified by the user -->


    <link href="/assets/css/myblog.css" type="text/css" rel="stylesheet" />

  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


    <link href="/2017/08/snakemake-tutorial-for-data-analysts.html" rel="canonical" />

        <meta name="description" content="Motivation Data analyses are performed to extract the pertinent informations from a data sample. The task is complex and usually lasts...">

        <meta name="author" content="Marko">

        <meta name="tags" content="Tutorials">




<!-- Open Graph -->
<meta property="og:site_name" content="Marko Stamenkovic"/>
<meta property="og:title" content="Analysis preservation using Snakemake"/>
<meta property="og:description" content="Motivation Data analyses are performed to extract the pertinent informations from a data sample. The task is complex and usually lasts..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="/2017/08/snakemake-tutorial-for-data-analysts.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-08-02 17:36:00+02:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="/author/marko">
<meta property="article:section" content="misc"/>
<meta property="article:tag" content="Tutorials"/>
<meta property="og:image" content="/assets/images/AP.jpg">

<!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@StamenkM">
    <meta name="twitter:title" content="Analysis preservation using Snakemake">
    <meta name="twitter:url" content="/2017/08/snakemake-tutorial-for-data-analysts.html">

        <meta name="twitter:image:src" content="/assets/images/AP.jpg">

      <meta name="twitter:description" content="Motivation Data analyses are performed to extract the pertinent informations from a data sample. The task is complex and usually lasts...">

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Analysis preservation using Snakemake",
  "headline": "Analysis preservation using Snakemake",
  "datePublished": "2017-08-02 17:36:00+02:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Marko",
    "url": "/author/marko"
  },
  "image": "/assets/images/AP.jpg",
  "url": "/2017/08/snakemake-tutorial-for-data-analysts.html",
  "description": "Motivation Data analyses are performed to extract the pertinent informations from a data sample. The task is complex and usually lasts..."
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>

              <li role="presentation"><a href="/pages/about-me/">About me</a></li>
              <li role="presentation"><a href="/pages/contact-me/">Contact me</a></li>
              <li role="presentation"><a href="/pages/tutorials/">Tutorials</a></li>

    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="post-header" class="has-cover">
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="/" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Analysis preservation using Snakemake</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="/author/marko">Marko</a>
            | <time datetime="02 Aug 2017">02 Aug 2017</time>
        </span>
        <!-- TODO : Modified check -->
            <div class="post-cover cover" style="background-image: url('/assets/images/AP.jpg')">
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h2>Motivation</h2>
<p>Data analyses are performed to extract the pertinent informations from a data sample. The task is complex and usually lasts on an extended period of time. It involves many people organised in small groups. One frequent problem in data analysis is that after a certain amount of time reading some old scripts and codes becomes as hard as reading codes written by someone else. Reproducing the results obtained in the beginning of the analysis systematically took more time than it should. At CERN for example, a great effort is focused on <a href="https://analysispreservation.cern.ch/experiments" target="_blank"><strong>Analysis Preservation</strong></a>.  For this reason, we started using <a href="http://snakemake.readthedocs.io/en/stable/" target="_blank">Snakemake</a>. </p>
<h2>Credit</h2>
<p>On the idea of <a href="http://pluca.webnode.com/" target="_blank">Luca Pescatore</a>, we used Snakemake during my master thesis and it appeared to be a crucial tool. We therefore decided to write this tutorial to detail some of our techniques and we hope it will help to spread it among the physics community. </p>
<h2>Index</h2>
<ol>
<li><a href="#snakemakegit">Snakemake and git: the perfect combination</a></li>
<li><a href="#require">Requirements for the tutorial</a></li>
<li><a href="#install">Installation on Linux (MacOSX)</a></li>
<li><a href="#simpleex">Simple example: plotting various function</a></li>
<li><a href="#setup">Setting up the environment - setup.sh (Portability)</a></li>
<li><a href="#snakefile">Snakemake rules - Snakefile</a></li>
<li><a href="#reproducibility">Reproducibility</a></li>
</ol>
<p><a name="snakemakegit"></a></p>
<h2>Snakemake and git: the perfect combination</h2>
<p>I picture Snakemake as some kind of memory stick to help you store every single steps (or commands) involved in your analysis. As a good memory stick, you can easily share it. </p>
<p>Snakemake is a workflow management system. It basically helps you build pipelines between the various scripts involved in your analysis and their respective inputs and outputs. Snakemake workflows are Python scripts extended by declarative codes to define rules. Once the Snakemake environment is set, one can run multiple rules directly from the command line. By specifying the dependencies between the various scripts, e.g. the output from the rule <em>n</em> is the input from the rule <em>n+1</em>, Snakemake explicitly stores the full architecture of your analysis. Theoretically, if every rule produces an output, one should be able to rerun a complete analysis with a single command. This is where the combination with git becomes really interesting, if the analysis is built in a user-sensitive way, every people involved in the analysis could reproduce any results by a single command in a terminal, without having to open nor read a single line of code written by someone else. </p>
<p>We call this concept <strong>analyis preservation</strong> and it offers several advantages:</p>
<ul>
<li>Memory: stores the architecture of the work and allows you to rapidly perform a complete or partial analysis.   </li>
<li>Portability: if built in a user-sensitive way, anyone working on the same analysis can obtain every results.</li>
<li>Modularity: as a rule is only a path between an input and an output, if one method or technique used in the analysis needs to be updated or modified, it can be replaced by a new rule with the same output. It allows a parallel comparison of different techniques in a very simple way.</li>
<li>Reproducibility: if you're analysing a data sample collected by the same experiment in different years of exploitation and you plan to analyse data samples not even collected yet, Snakemake is a simple solution to perform the same analysis to different data sets.</li>
</ul>
<p>Of course, as every good tools, Snakemake takes some time to set up but spares you countless hours and especially right before deadlines. The purpose of this tutorial is to detail the installation, one simple application and to propose some solutions for the portability and reproducibility. Naturally, these solutions are our own, if you have some better ideas please contact me at <a href="mailto:stamenkovim@gmail.com">stamenkovim@gmail.com</a> or <a href="https://twitter.com/StamenkM" target="_blank">Twitter</a>. </p>
<p><a name="require"></a></p>
<h2>Requirements for the tutorial</h2>
<p>For this tutorial, we assume you'll be working from a shell terminal and you have some basic notions of bash, a running python environment and a basic c++ compiler with c++11, e.g. g++.</p>
<p><a name="install"></a></p>
<h2>Installation on Linux (MacOSX)</h2>
<p>The easiest way to install Snakemake is via Conda. First make sure that you have the latest version of <a href="https://repo.continuum.io/miniconda/" target="_blank">Miniconda installed</a>. </p>
<p>If you're working on Linux, run the following commands in the terminal:</p>
<div class="highlight"><pre><span></span>apt-get install wget
wget <span class="s1">&#39;https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh&#39;</span>
chmod +x Miniconda3-latest-Linux-x86_64.sh
./Miniconda3-latest-Linux-x86_64.sh
</pre></div>


<p>If you're on MacOS:</p>
<div class="highlight"><pre><span></span>curl https://repo.continuum.io/miniconda/Miniconda3-latest-MacOSX-x86_64.sh &gt; Miniconda3-latest-MacOSX-x86_64.sh
chmod +x Miniconda3-latest-MacOSX-x86_64.sh
./Miniconda3-latest-MacOSX-x86_64.sh
</pre></div>


<p>Once you have the latest version of Miniconda, just run the following commands to download Snakemake and the various libraries required.</p>
<div class="highlight"><pre><span></span>conda update conda
conda create -n snake -c bioconda <span class="nv">python</span><span class="o">=</span>3.4 snakemake beautiful-soup pyyaml
conda install -n snake -c https://conda.anaconda.org/conda-forge gitpython
conda install -n snake -c https://conda.anaconda.org/anaconda pytz
</pre></div>


<p>If everything went well, you should be able to activate and deactivate the Snakemake environment</p>
<div class="highlight"><pre><span></span><span class="nb">source</span> activate snake
<span class="nb">source</span> deactivate
</pre></div>


<p>See the <a href="http://snakemake.readthedocs.io/en/stable/" target="_blank">official manual</a> for more detailed informations. </p>
<p><a name="simpleex"></a></p>
<h2>Simple example: plotting various functions</h2>
<p><img alt="Example" src="https://mstamenk.github.io/assets/images/Cubic_forPlotting.png"></p>
<p>The purpose of this tutorial is to show you the basics of Snakemake by building a simple example of a workflow. The idea is to demonstrate how easy it is to handle different programming languages as well as a complete architecture of a project within the executing environment. Furthermore, the simple example presented in this tutorial is meant to demonstrate the <strong>Memory</strong> advantage of the Snakemake environment. It's also a good starting point to present our solutions for the <strong>Portability</strong> also referred as User-Sensitivity and the <strong>Reproducibility</strong>. The two latter are not directly a consequence of Snakemake but those properties are really simplified once set correctly. </p>
<p>In order to make it more interesting, we prepared a tutorial starter that can be downloaded from <a href="https://github.com/mstamenk/snakemake-tutorial-starter" target="_blank">Github</a> or directly from the command line:</p>
<div class="highlight"><pre><span></span>git clone https://github.com/mstamenk/snakemake-tutorial-starter.git
</pre></div>


<p>The simple example uses mainly three programming languages: bash, c++ and python. The architecture goes as follows:</p>
<div class="highlight"><pre><span></span><span class="c1"># Architecture of the project</span>
<span class="p">|</span>--snakemake-tutorial-starter
          <span class="p">|</span>--setup.sh                 <span class="c1"># TO BE COMPLETED</span>
          <span class="p">|</span>--Snakefile                <span class="c1"># TO BE COMPLETED</span>
          <span class="p">|</span>--config.yml               <span class="c1"># TO BE COMPLETED</span>
          <span class="p">|</span>--scripts
                <span class="p">|</span>--setup_path.sh      <span class="c1"># TO BE COMPLETED </span>
          <span class="p">|</span>--routines
                <span class="p">|</span>--Analysis.py        <span class="c1"># COMPLETE</span>
          <span class="p">|</span>--python
                <span class="p">|</span>--process.py         <span class="c1"># COMPLETE</span>
                <span class="p">|</span>--plot.py            <span class="c1"># COMPLETE</span>
          <span class="p">|</span>--cpp
                <span class="p">|</span>--src
                      <span class="p">|</span>--produce.cpp  <span class="c1"># COMPLETE</span>
          <span class="p">|</span>--resource
</pre></div>


<h4>C++ - produce.cpp</h4>
<p>The c++ file <code>produce.cpp</code> is a basic code solving the equation <code>y=f(x)</code> for 4 different modes : <em>Zero</em> , <em>Linear</em> , <em>Square</em> and <em>Cubic</em>. It's built in such a way that, once compiled, every informations can be detailed in the command line:</p>
<div class="highlight"><pre><span></span>./produce.out --mode Square 
              --start <span class="m">10</span> 
              --end <span class="m">100</span> 
              --location /path/to/folder/ 
              --saveName Square_forPlotting.dat
</pre></div>


<p>For example, the previous command will solve the equation <code>y=x*x</code> for every integers between <code>10</code> and <code>100</code> and save them in the file <code>/path/to/folder/Square_forPlotting.dat</code>. The final output contains two columns with the <code>x</code> and <code>y</code> values. </p>
<h4>Python - Analysis.py  - process.py - plot.py</h4>
<p>Python is used to superficially handle the different filenames, plot colours and locations required in the analysis. </p>
<p><strong>Analysis.py</strong></p>
<p>This file is the center of the full architecture. It contains every path definition to the various directories in the project as well as the names and specificities of every resource files produced or required. The locations are fetched from a bash script. </p>
<p><strong>process.py</strong></p>
<p>The script <code>process.py</code> simply runs the c++ executable. In some sense, it doesn't add any important information but we choose to run everything from a python script in order to impose the location and the name of the file in which the produced informations are stored. For example, the data produced by the executable for the mode <em>Linear</em> will be stored in the <code>resource</code> directory under the name <code>Linear_forPlotting.dat</code> and plotted in cyan. All these informations are stored in the <code>Analysis.py</code> script and therefore, we make sure that throughout the analysis, we don't need to take care of the names of the various files containing informations as they are all produced and read from the central script <code>Analysis.py</code>.</p>
<p>The following command line is used for the script:</p>
<div class="highlight"><pre><span></span>python process.py --mode Square --start <span class="m">10</span> --end <span class="m">100</span> 
</pre></div>


<p><strong>plot.py</strong></p>
<p>The script <code>plot.py</code> simply reads, for a specific mode, the various informations stored in the <code>resource</code> folder. </p>
<div class="highlight"><pre><span></span>python plot.py --mode Square
</pre></div>


<p>The previous command will read the file <code>resource/Square_forPlotting.dat</code> and plot the various modes with their respective colors to finally store them in the folder <code>plots/</code> which location is defined in a user-sensitive way in <code>setup.sh</code>. </p>
<p><a name="setup"></a></p>
<h2>Setting up the environment - setup.sh</h2>
<p>In order to use Snakemake efficiently, we usually work with at least 2 terminals, one with the snake environment activated and another one with an interactive working environment. Also, Snakemake requires <strong>python3</strong>. Sometimes, depending on your working habits or the machine on which you perform your analyses, you might want to use <strong>python2</strong>. We use a single bash script to set the two different environments and handle the proper version of python required for the various scripts. </p>
<div class="highlight"><pre><span></span><span class="c1"># setup.sh</span>
<span class="c1">#Setting the environment snake/interactive</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;snake&quot;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;Setup with snakemake using python3&quot;</span>
    <span class="nb">source</span> activate snake  
<span class="k">else</span> 
    <span class="nb">echo</span> <span class="s2">&quot;Setup without snakemake using python2&quot;</span>
<span class="c1">#    source scripts/setup_path.sh   # Uncomment for python2</span>
<span class="k">fi</span>
</pre></div>


<p>The first block defines the environment. One single script can define two different environments. From the command line(terminal): </p>
<div class="highlight"><pre><span></span><span class="nb">source</span> setup.sh snake  <span class="c1"># For the snake environment</span>
<span class="nb">source</span> setup.sh        <span class="c1"># For the interactive environment</span>
</pre></div>


<p>If the scripts you plan to run with Snakemake are written for python2, one more step is required to set the complete working environment. You need to specify the <code>$PATH</code> to your python2 version. This can be found from the command line:</p>
<div class="highlight"><pre><span></span>which python2
</pre></div>


<p>In my case, I use the <code>anaconda</code> distribution and the result of the previous command line is <code>/Users/marko/anaconda/bin/python2</code>. Therefore, I add the following line to the script <code>scripts/setup_path.sh</code>:</p>
<div class="highlight"><pre><span></span><span class="c1"># scripts/setup_path.sh</span>
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;/Users/marko/anaconda/bin:</span><span class="nv">$PATH</span><span class="s2">&quot;</span>
</pre></div>


<p>Once everything updated, if you open two terminals you should be able to set one Snakemake environment with python3 and one interactive environment with python2. I usually use the snake environment as an executing terminal where I run the commands once every script are correctly computed and the terminal with the interactive environment as a testing/developing environment. </p>
<p>Back to the <code>setup.sh</code>, we simply define the macros with the various locations of the folders in the project. This way, every locations are directly accessible from every programming languages involved in the analysis as well as the command line. For this tutorial, these locations are fetched in the <code>routines/Analysis.py</code> script. </p>
<div class="highlight"><pre><span></span><span class="c1"># setup.sh</span>
<span class="c1"># Definition of various path in the architecture of the project</span>
<span class="nb">export</span> <span class="nv">TUTO</span><span class="o">=</span><span class="nv">$PWD</span>
<span class="nb">export</span> <span class="nv">CPP</span><span class="o">=</span><span class="nv">$PWD</span>/cpp
<span class="nb">export</span> <span class="nv">CPPSRC</span><span class="o">=</span><span class="nv">$CPP</span>/src
<span class="nb">export</span> <span class="nv">SCRIPTS</span><span class="o">=</span><span class="nv">$PWD</span>/scripts
<span class="nb">export</span> <span class="nv">PYTHON</span><span class="o">=</span><span class="nv">$PWD</span>/python
<span class="nb">export</span> <span class="nv">RESOURCE</span><span class="o">=</span><span class="nv">$PWD</span>/resource
<span class="nb">export</span> <span class="nv">ROUTINES</span><span class="o">=</span><span class="nv">$PWD</span>/routines
</pre></div>


<p>The <strong>Portability</strong> or <strong>User-Sensitivity</strong> is defined directly in the bash script. This is useful if you have a certain routine which is different from your colleagues and for example you store your informations, resources or even results in folders that are not in the project directory. Therefore, if you're working in group, you would like the locations of the specific folders to be defined in one place and never think about it again. One solution is to do it directly in the <code>setup.sh</code>. In this example, I define a folder <code>Desktop/plots/</code> which is not absolute and only accessible for me. If you want to run this example on your machine, you need to create a directory and indicate its path in the <code>elif</code> statement. Don't forget to complete the condition <code>$USER = ""</code> where from a shell terminal you can find the value of <code>$USER</code> with the command <code>echo $USER</code>.</p>
<div class="highlight"><pre><span></span><span class="c1"># setup.sh</span>
<span class="c1"># Portability (User-sensitivity) - &quot;echo $USER&quot; in command line</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$USER</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;marko&quot;</span> <span class="o">]</span>
<span class="k">then</span>
    <span class="nb">export</span> <span class="nv">PLOTS</span><span class="o">=</span><span class="nv">$HOME</span>/Desktop/plots
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$USER</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;COMPLETE HERE&quot;</span> <span class="o">]</span> 
<span class="k">then</span>
    <span class="nb">export</span> <span class="nv">PLOTS</span><span class="o">=</span>/PATH/TO/PLOTS
<span class="k">else</span>
    <span class="nb">echo</span> <span class="s2">&quot;Don&#39;t forget to compelte the paths in the setup.sh in order to run the scripts!&quot;</span>
<span class="k">fi</span>
</pre></div>


<p>Two more lines are required to finalise the working environment. We need to specify the <code>$PYTHONPATH</code> so the modules defined in different folders can be imported one into the other (this step is specific to the way python works). The last line about the <code>PY2</code> ensures that even if we are working in the snake environment, you still have access to the python2 version. </p>
<div class="highlight"><pre><span></span><span class="c1"># setup.sh</span>
<span class="c1"># Required to import modules in python</span>
<span class="nb">export</span> <span class="nv">PYTHONPATH</span><span class="o">=</span><span class="nv">$PYTHONPATH</span>:<span class="nv">$TUTO</span>:<span class="nv">$ROUTINES</span>:<span class="nv">$PYTHON</span>:<span class="nv">$PY2</span>

<span class="c1"># Complete if the scripts require python2</span>
<span class="nb">export</span> <span class="nv">PY2</span><span class="o">=</span>path/to/python2
</pre></div>


<p>In conclusion, the <code>setup.sh</code> bash script has the following advantage:</p>
<ul>
<li>Environment setup: we use one script to set up the two different environments (snake and interactive). </li>
<li>Locations definition: we define the various locations required in our analysis. Since they are defined from a bash script, they are accessible from the terminal and from every programming languages. </li>
<li>Portability - User-Sensitivity: The locations specific to the users are defined in a user-sensitive way and all handled in a single place. For a group project, a simple update of the repertories (through git) should work without any user-dependant modifications. </li>
<li>Python multiplicity: the bash script allows the use of multiple versions of python which are simply specified. </li>
</ul>
<p><a name="snakefile"></a></p>
<h2>Snakemake rules - Snakefile</h2>
<p>In order to specify the various rules, the snake environment requires a <strong>Snakefile</strong> (if your working with vi/vim you might be interested in the syntax file presented in this <a href="https://mstamenk.github.io/2017/08/snakefile-syntax-file-for-vi-vim.html" target="_blank">tutorial</a>). For this example, we need to write the rules to run the scripts from the production of the data to the plotting. The steps are the following:</p>
<ol>
<li>Compile the <code>produce.cpp</code> file in an executable <code>produce.out</code></li>
<li>Produce the data with the <code>produce.out</code> exectuable through the <code>process.py</code> script</li>
<li>Plot the data with the script <code>plot.py</code></li>
</ol>
<p>The <code>Snakefile</code> is located in the main directory of the project. The first rule we write is the one to compile the c++ file:</p>
<div class="highlight"><pre><span></span><span class="c1"># Snakefile</span>
<span class="n">rule</span> <span class="nb">compile</span><span class="p">:</span>
    <span class="nb">input</span><span class="p">:</span> 
        <span class="n">script</span> <span class="o">=</span> <span class="s1">&#39;cpp/src/produce.cpp&#39;</span>
    <span class="n">output</span><span class="p">:</span>
        <span class="n">exe</span>    <span class="o">=</span> <span class="s1">&#39;cpp/produce.out&#39;</span>
    <span class="n">shell</span><span class="p">:</span>
        <span class="s2">&quot;g++ -std=c++11 {input.script} -o {output.exe}&quot;</span>
</pre></div>


<p>The syntax of a rule is really easy to understand. In this example, the name of the rule is <code>compile</code>, the <code>input</code> contains one variable <code>script</code> and the <code>output</code> contains the executable <code>exe</code>. The <code>shell</code> command basically compiles the c++ file stored in <code>input</code> into an executable stored in <code>output</code> by using <code>g++</code> and the option <code>c++11</code>.   Now, in the shell terminal with the snake environment, from the directory containing the <code>Snakefile</code>, you can run the following command.</p>
<div class="highlight"><pre><span></span>snakemake compile
</pre></div>


<p>In this example, you can notice that the path are given in a relative way. It works because the <code>Snakefile</code> is in the main directory but let's imagine you have to change the architecture of the project for some reasons, if all the rules are defined in an relative way, it might take a certain amount of time to correct every path and it would be counter-productive. One clever way to overcome this issue is to use the <code>routines/Analysis.py</code> where every path of the project are defined in the variable <code>loc</code>. </p>
<div class="highlight"><pre><span></span><span class="c1"># Snakefile</span>
<span class="kn">from</span> <span class="nn">routines.Analysis</span> <span class="kn">import</span> <span class="n">loc</span>

<span class="n">rule</span> <span class="nb">compile</span><span class="p">:</span>
    <span class="nb">input</span><span class="p">:</span> 
        <span class="n">script</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">CPPSRC</span> <span class="o">+</span> <span class="s1">&#39;produce.cpp&#39;</span>
    <span class="n">output</span><span class="p">:</span>
        <span class="n">exe</span>    <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">CPP</span> <span class="o">+</span> <span class="s1">&#39;produce.out&#39;</span>
    <span class="n">shell</span><span class="p">:</span>
        <span class="s2">&quot;g++ -std=c++11 {input.script} -o {output.exe}&quot;</span>
</pre></div>


<p>The next step is the processing rule which requires specified options. Snakemake can take arguments directly in the command line through a syntax similar to python.</p>
<div class="highlight"><pre><span></span>snakemake process --config <span class="nv">mode</span><span class="o">=</span>Linear <span class="nv">start</span><span class="o">=</span><span class="m">20</span> <span class="nv">end</span><span class="o">=</span><span class="m">100</span> 
</pre></div>


<p>Of course, an easy solution exist to store the default configurations and modify only the ones you need in the command line. Create a <code>config.yml</code> file and fill it with the defaults values.</p>
<div class="highlight"><pre><span></span><span class="c1"># config.yml</span>
<span class="l l-Scalar l-Scalar-Plain">mode</span> <span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">Linear</span>
<span class="l l-Scalar l-Scalar-Plain">start</span> <span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">20</span>
<span class="l l-Scalar l-Scalar-Plain">end</span> <span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">100</span>
</pre></div>


<p>Once the file created, add the following line on the top of the <code>Snakefile</code>.</p>
<div class="highlight"><pre><span></span><span class="c1"># Snakefile</span>
<span class="n">configfile</span><span class="p">:</span> <span class="s1">&#39;config.yml&#39;</span>
</pre></div>


<p>Finally, we finish the pipeline by adding the rules <code>process</code> and <code>plot</code> to the <code>Snakefile</code>. We take advantage of the <code>routines/Analysis.py</code>file to handle the absolute path to the different files and we use the function <code>parseDatafiles(dtype)</code> to fetch the name of the <code>.dat</code>file as well as the respective colour for the plot.  </p>
<div class="highlight"><pre><span></span><span class="c1"># Snakefile</span>
<span class="kn">from</span> <span class="nn">routines.Analysis</span> <span class="kn">import</span> <span class="n">parseDatafiles</span>

<span class="n">setup_path</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">SCRIPTS</span> <span class="o">+</span> <span class="s1">&#39;setup_path.sh&#39;</span>

<span class="n">filename</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">parseDatafiles</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">])</span>
<span class="n">plotname</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.dat&#39;</span><span class="p">,</span><span class="s1">&#39;.pdf&#39;</span><span class="p">)</span> 

<span class="n">rule</span> <span class="n">process</span><span class="p">:</span>
    <span class="nb">input</span><span class="p">:</span>
        <span class="n">exe</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">CPP</span> <span class="o">+</span> <span class="s1">&#39;produce.out&#39;</span><span class="p">,</span>
        <span class="n">script</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">PYTHON</span> <span class="o">+</span> <span class="s1">&#39;process.py&#39;</span>
    <span class="n">output</span><span class="p">:</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">RESOURCE</span> <span class="o">+</span> <span class="n">filename</span>
    <span class="n">shell</span><span class="p">:</span>
        <span class="s2">&quot;source {setup_path} &amp;&amp; $PY2 {input.script} --mode {config[mode]} --start {config[start]} --end {config[end]}&quot;</span>

<span class="n">rule</span> <span class="n">plot</span><span class="p">:</span>
    <span class="nb">input</span><span class="p">:</span>
        <span class="n">script</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">PYTHON</span> <span class="o">+</span> <span class="s1">&#39;plot.py&#39;</span><span class="p">,</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">RESOURCE</span> <span class="o">+</span> <span class="n">filename</span>
    <span class="n">output</span><span class="p">:</span>
        <span class="n">plot</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">PLOTS</span> <span class="o">+</span> <span class="n">plotname</span>
    <span class="n">shell</span><span class="p">:</span>  
        <span class="s2">&quot;source {setup_path} &amp;&amp; $PY2 {input.script} --mode {config[mode]}&quot;</span>
</pre></div>


<p>This is the complete workflow. You might wonder why the shell command starts with a <code>'source scripts/setup_path.sh'</code>, this is in case you have other libraries you would like to add to your working environment. In our case, it's not a necessary step. </p>
<p>Now, you can run the complete job with a single command. </p>
<div class="highlight"><pre><span></span>snakemake plot
</pre></div>


<p>It should check for the missing files and create them in order to run the final rule. </p>
<p>Finally, if you want Snakemake to rerun the rules where some inputs were modified, you have to trigger it first in the command line. </p>
<div class="highlight"><pre><span></span> snakemake -n -R <span class="sb">`</span>snakemake --list-input-changes<span class="sb">`</span>
</pre></div>


<p>Now, if you change the file <code>produce.cpp</code> and run the command <code>snakemake plot --config mode=Square</code> it will automatically compile the executable first and rerun every rules.</p>
<p><a name="reproducibility"></a></p>
<h2>Reproducibility</h2>
<p>Let's now consider your working on an analysis with multiple data sets, taken at a different year for example. You have built your complete analysis using Snakemake and you would like a simple way to run the same steps for the new data sample. Let's also assume that the type of data set is really similar to the one on which you built Snakemake. The answer is again in the file <code>routines/Analysis.py</code>.</p>
<div class="highlight"><pre><span></span><span class="c1"># routines/Analysis.py</span>
<span class="n">NAME</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">COLOR</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">dataID</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;Zero&#39;</span>   <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Zero_forPlotting.dat&#39;</span><span class="p">,</span>  <span class="s1">&#39;b&#39;</span><span class="p">],</span>
           <span class="s1">&#39;Linear&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Linear_forPlotting.dat&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],</span>
           <span class="s1">&#39;Square&#39;</span> <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Square_forPlotting.dat&#39;</span><span class="p">,</span><span class="s1">&#39;m&#39;</span><span class="p">],</span>
           <span class="s1">&#39;Cubic&#39;</span>  <span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Cubic_forPlotting.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span> <span class="p">]}</span>

<span class="k">def</span> <span class="nf">parseDatafiles</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span> 
    <span class="k">return</span> <span class="n">dataID</span><span class="p">[</span><span class="n">dtype</span><span class="p">][</span><span class="n">NAME</span><span class="p">],</span><span class="n">dataID</span><span class="p">[</span><span class="n">dtype</span><span class="p">][</span><span class="n">COLOR</span><span class="p">]</span>
</pre></div>


<p>If you build your complete analysis using the function <code>parseDatafiles</code>, meaning that every scripts requiring one resource fetches it through this function, by modifying the function itself you should be able to run everything in one single command.</p>
<h2>Conclusion</h2>
<p>In summary, Snakemake is a powerful tool for <strong>analysis preservation</strong>. It stores the shell commands that you use throughout your analysis as well as the various ways to run your own scripts. One solution to make it user-sensitive and reproducible is to use the <code>setup.sh</code> and <code>routines/Analysis.py</code> files together. The other advantage we didn't develop in this tutorial is the fact that if you receive a complete analysis via a Snakemake + Git interface and you are not satisfied with one script. You prefer a certain optimisation technique over the one used in the current script, you can just create your custom script and replace the rule without changing the workflow. We call this concept <strong>Modularity</strong>. </p>
<p>Finally, the four advantages greatly simplified by Snakemake are the <strong>Memory</strong>, <strong>Portability</strong>, <strong>Modularity</strong> and <strong>Reproducibility</strong>. We hope you appreciated! If you have any comments, suggestions or critics: <a href="mailto:stamenkovim@gmail.com">stamenkovim@gmail.com</a> or <a href="https://twitter.com/StamenkM" target="_blank">Twitter</a>. Thank you! </p>
<h2>See also the other tutorials</h2>
<ul>
<li><a href="https://mstamenk.github.io/pages/tutorials/" target="_blank">Full list of tutorials</a></li>
<li><a href="https://mstamenk.github.io/2017/08/snakefile-syntax-file-for-vi-vim.html" target="_blank">Snakefile syntax file for vi/vim</a></li>
</ul>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Analysis preservation using Snakemake&amp;url=/2017/08/snakemake-tutorial-for-data-analysts.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=/2017/08/snakemake-tutorial-for-data-analysts.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=/2017/08/snakemake-tutorial-for-data-analysts.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="/tag/tutorials">Tutorials</a>                </aside>

                <div class="clear"></div>

                <aside class="post-author">


                        <figure class="post-author-avatar">
                            <img src="/assets/images/Profile.JPG" alt="Marko" />
                        </figure>
                    <div class="post-author-bio">
                        <h4 class="post-author-name"><a href="/author/marko">Marko</a></h4>
                            <p class="post-author-about">Swiss particle physicist, I am currently a PhD student within the ATLAS collaboration (CERN) and I am based at Nikhef, Amsterdam, Netherlands. Enjoy my blog!</p>
                            <span class="post-author-location"><i class="ic ic-location"></i> Lausanne, Switzerland</span>
                            <span class="post-author-website"><a href="http://mstamenk.github.io"><i class="ic ic-link"></i> Website</a></span>
                            <span class="post-author-twitter"><a target="_blank" href="https://twitter.com/StamenkM"><i class="ic ic-twitter"></i> Twitter</a></span>
                    </div>
                    <div class="clear"></div>
                </aside>

                </section>


                <aside class="post-nav">
                    <a class="post-nav-next" href="/2017/08/snakefile-syntax-file-for-vi-vim.html">
                        <section class="post-nav-teaser">
                            <i class="ic ic-arrow-left"></i>
                                <h2 class="post-nav-title">Snakefile syntax file for vi/vim</h2>
                            <p class="post-nav-excerpt">Motivation If you're using vi/vim, you might want to use a colour syntax file for you...</p>
                        </section>
                    </a>
                    <a class="post-nav-prev" href="/2017/08/my-first-post.html">
                        <section class="post-nav-teaser">
                            <i class="ic ic-arrow-right"></i>
                                <h2 class="post-nav-title">My first post</h2>
                            <p class="post-nav-excerpt">Welcome to my blog ! This is a glimpse in my universe and my first attempt at...</p>
                        </section>
                    </a>
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="/theme/js/script.js"></script>

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-103991222-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
</body>
</html>